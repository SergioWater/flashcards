{
  "definition_questions": [
    {
      "id": "Q1-1",
      "question": "Which option matches the following definition? \"Runs without being visibly active to the user; does not occupy the main screen.\"",
      "options": [
        "background",
        "foreground",
        "display",
        "main"
      ],
      "answer": "background",
      "explanation": "This definition describes a background application."
    },
    {
      "id": "Q1-2",
      "question": "Which option matches the following definition? \"Currently active application shown on the display.\"",
      "options": [
        "background",
        "foreground",
        "display",
        "main"
      ],
      "answer": "foreground",
      "explanation": "This is the app that appears on screen and takes user input."
    },
    {
      "id": "Q1-3",
      "question": "Which option matches the following definition? \"Refers to the actual screen or visual output device, not an application.\"",
      "options": [
        "background",
        "foreground",
        "display",
        "main"
      ],
      "answer": "display",
      "explanation": "The 'display' is typically the screen or output device."
    },
    {
      "id": "Q1-4",
      "question": "Which option matches the following definition? \"A vague term here; not the standard OS name for the visible app.\"",
      "options": [
        "background",
        "foreground",
        "display",
        "main"
      ],
      "answer": "main",
      "explanation": "In this context, 'main' is too vague for describing the active screen application."
    },
    {
      "id": "Q2-1",
      "question": "Which option matches the following definition? \"Blocks the calling process until one of its child processes finishes.\"",
      "options": [
        "wait()",
        "fork()",
        "abort()",
        "exec()"
      ],
      "answer": "wait()",
      "explanation": "wait() suspends the parent process until a child terminates."
    },
    {
      "id": "Q2-2",
      "question": "Which option matches the following definition? \"Creates a new child process by duplicating the calling (parent) process.\"",
      "options": [
        "wait()",
        "fork()",
        "abort()",
        "exec()"
      ],
      "answer": "fork()",
      "explanation": "fork() is used to create a new child process."
    },
    {
      "id": "Q2-3",
      "question": "Which option matches the following definition? \"Ends a process abnormally, often used when errors occur.\"",
      "options": [
        "wait()",
        "fork()",
        "abort()",
        "exec()"
      ],
      "answer": "abort()",
      "explanation": "abort() terminates a process immediately without normal cleanup."
    },
    {
      "id": "Q2-4",
      "question": "Which option matches the following definition? \"Replaces the current process image with a new program.\"",
      "options": [
        "wait()",
        "fork()",
        "abort()",
        "exec()"
      ],
      "answer": "exec()",
      "explanation": "exec() loads and runs a new program in the same process (same PID)."
    },
    {
      "id": "Q3-1",
      "question": "Which option matches the following definition? \"A hierarchical data structure often used for parent-child relationships like directories.\"",
      "options": [
        "tree",
        "hash map",
        "linked list",
        "stack"
      ],
      "answer": "tree",
      "explanation": "A tree structure is hierarchical, but not the main structure for Linux process scheduling lists."
    },
    {
      "id": "Q3-2",
      "question": "Which option matches the following definition? \"A key-value data structure that provides fast lookups by key.\"",
      "options": [
        "tree",
        "hash map",
        "linked list",
        "stack"
      ],
      "answer": "hash map",
      "explanation": "Hash maps are not typically used as the main global process list in the Linux kernel."
    },
    {
      "id": "Q3-3",
      "question": "Which option matches the following definition? \"A sequence of elements where each node points to the next, used for easy insertion/removal.\"",
      "options": [
        "tree",
        "hash map",
        "linked list",
        "stack"
      ],
      "answer": "linked list",
      "explanation": "Linux uses linked lists for many scheduling structures (e.g. task lists)."
    },
    {
      "id": "Q3-4",
      "question": "Which option matches the following definition? \"A LIFO (Last-In-First-Out) structure typically used for function calls.\"",
      "options": [
        "tree",
        "hash map",
        "linked list",
        "stack"
      ],
      "answer": "stack",
      "explanation": "The stack is used for function calls, not for storing process control blocks globally."
    },
    {
      "id": "Q4-1",
      "question": "Which option matches the following definition? \"A process that spends more time performing I/O than computations.\"",
      "options": [
        "An I/O-bound process is one that spends more time doing I/O than computations",
        "Both of the other 2 (other than none)",
        "none of the other answers",
        "An I/O-bound process spends more time doing computations than I/O"
      ],
      "answer": "An I/O-bound process is one that spends more time doing I/O than computations",
      "explanation": "This is the correct definition for an I/O-bound process."
    },
    {
      "id": "Q4-2",
      "question": "Which option matches the following definition? \"States that two other statements might both be correct simultaneously.\"",
      "options": [
        "An I/O-bound process is one that spends more time doing I/O than computations",
        "Both of the other 2 (other than none)",
        "none of the other answers",
        "An I/O-bound process spends more time doing computations than I/O"
      ],
      "answer": "Both of the other 2 (other than none)",
      "explanation": "This option indicates multiple statements could be true."
    },
    {
      "id": "Q4-3",
      "question": "Which option matches the following definition? \"Implies no valid statement among the listed choices.\"",
      "options": [
        "An I/O-bound process is one that spends more time doing I/O than computations",
        "Both of the other 2 (other than none)",
        "none of the other answers",
        "An I/O-bound process spends more time doing computations than I/O"
      ],
      "answer": "none of the other answers",
      "explanation": "Used if the other statements are incorrect."
    },
    {
      "id": "Q4-4",
      "question": "Which option matches the following definition? \"Describes a CPU-bound process, not an I/O-bound process.\"",
      "options": [
        "An I/O-bound process is one that spends more time doing I/O than computations",
        "Both of the other 2 (other than none)",
        "none of the other answers",
        "An I/O-bound process spends more time doing computations than I/O"
      ],
      "answer": "An I/O-bound process spends more time doing computations than I/O",
      "explanation": "This is the opposite of an I/O-bound process."
    },
    {
      "id": "Q5-1",
      "question": "Which option matches the definition? \"Holds global/static variables; typically fixed in size at load time.\"",
      "options": [
        "data section",
        "heap section",
        "text section",
        "stack section"
      ],
      "answer": "data section",
      "explanation": "The data section stores global/static variables, not dynamic allocations."
    },
    {
      "id": "Q5-2",
      "question": "Which option matches the definition? \"Holds dynamic allocations (malloc/new); often grows upward in memory.\"",
      "options": [
        "data section",
        "heap section",
        "text section",
        "stack section"
      ],
      "answer": "heap section",
      "explanation": "Heap is used for memory allocated at runtime."
    },
    {
      "id": "Q5-3",
      "question": "Which option matches the definition? \"Contains the program instructions (code), typically read-only.\"",
      "options": [
        "data section",
        "heap section",
        "text section",
        "stack section"
      ],
      "answer": "text section",
      "explanation": "Text section is the compiled instructions of the program."
    },
    {
      "id": "Q5-4",
      "question": "Which option matches the definition? \"Grows from high memory to low memory to store function calls, local variables, and return addresses.\"",
      "options": [
        "data section",
        "heap section",
        "text section",
        "stack section"
      ],
      "answer": "stack section",
      "explanation": "The stack expands downward as new frames are pushed."
    },
    {
      "id": "Q6-1",
      "question": "Which option matches the definition? \"The process finished execution or was killed; resources released.\"",
      "options": [
        "terminated",
        "ready",
        "waiting",
        "new"
      ],
      "answer": "terminated",
      "explanation": "A terminated process has completed and is no longer active."
    },
    {
      "id": "Q6-2",
      "question": "Which option matches the definition? \"The process resides in memory and is waiting for CPU time.\"",
      "options": [
        "terminated",
        "ready",
        "waiting",
        "new"
      ],
      "answer": "ready",
      "explanation": "A ready process is available to run but is not currently executing."
    },
    {
      "id": "Q6-3",
      "question": "Which option matches the definition? \"The process is blocked, waiting for an event like I/O completion.\"",
      "options": [
        "terminated",
        "ready",
        "waiting",
        "new"
      ],
      "answer": "waiting",
      "explanation": "A running process moves to waiting if it must wait for I/O or an event."
    },
    {
      "id": "Q6-4",
      "question": "Which option matches the definition? \"The process is being created and not yet placed in the ready queue.\"",
      "options": [
        "terminated",
        "ready",
        "waiting",
        "new"
      ],
      "answer": "new",
      "explanation": "A new process is still in the admission stage."
    },
    {
      "id": "Q7-1",
      "question": "Which option matches the definition? \"Memory area used for allocations by malloc() or new.\"",
      "options": [
        "heap section",
        "data section",
        "text section",
        "stack section"
      ],
      "answer": "heap section",
      "explanation": "Dynamic allocations come from the heap."
    },
    {
      "id": "Q7-2",
      "question": "Which option matches the definition? \"Holds global/static variables, allocated at load time.\"",
      "options": [
        "heap section",
        "data section",
        "text section",
        "stack section"
      ],
      "answer": "data section",
      "explanation": "Data section is for global/static data."
    },
    {
      "id": "Q7-3",
      "question": "Which option matches the definition? \"Stores program instructions (CPU-executable code).\"",
      "options": [
        "heap section",
        "data section",
        "text section",
        "stack section"
      ],
      "answer": "text section",
      "explanation": "Text section is the compiled code segment."
    },
    {
      "id": "Q7-4",
      "question": "Which option matches the definition? \"Area used for local variables and function frames, grows downward.\"",
      "options": [
        "heap section",
        "data section",
        "text section",
        "stack section"
      ],
      "answer": "stack section",
      "explanation": "Call stack memory is typically allocated here."
    },
    {
      "id": "Q8-1",
      "question": "Which option matches the definition? \"A short-term scheduler that decides which ready process will run next.\"",
      "options": [
        "CPU scheduler",
        "context switch",
        "job scheduler",
        "swapping"
      ],
      "answer": "CPU scheduler",
      "explanation": "The CPU scheduler picks the next process from the ready queue."
    },
    {
      "id": "Q8-2",
      "question": "Which option matches the definition? \"Mechanism that saves one process’s state and loads another’s.\"",
      "options": [
        "CPU scheduler",
        "context switch",
        "job scheduler",
        "swapping"
      ],
      "answer": "context switch",
      "explanation": "Context switching is how the CPU switches from one process to another."
    },
    {
      "id": "Q8-3",
      "question": "Which option matches the definition? \"A long-term scheduler that decides which jobs enter the system (often in batch).\"",
      "options": [
        "CPU scheduler",
        "context switch",
        "job scheduler",
        "swapping"
      ],
      "answer": "job scheduler",
      "explanation": "Job scheduler (or long-term scheduler) picks which processes are admitted to the ready queue."
    },
    {
      "id": "Q8-4",
      "question": "Which option matches the definition? \"Moving entire processes from main memory to disk or vice versa.\"",
      "options": [
        "CPU scheduler",
        "context switch",
        "job scheduler",
        "swapping"
      ],
      "answer": "swapping",
      "explanation": "Swapping deals with memory management, not CPU scheduling directly."
    },
    {
      "id": "Q9-1",
      "question": "Which option matches the definition? \"Saves P0’s state in PCB1 and loads from PCB0.\"",
      "options": [
        "PCB1, PCB0",
        "PCB0, PCB1",
        "PCB1, PCB1",
        "PCB0, PCB0"
      ],
      "answer": "PCB1, PCB0",
      "explanation": "This incorrectly overwrites P1's PCB with P0's state."
    },
    {
      "id": "Q9-2",
      "question": "Which option matches the definition? \"Saves P0’s state in PCB0 and loads P1’s state from PCB1.\"",
      "options": [
        "PCB1, PCB0",
        "PCB0, PCB1",
        "PCB1, PCB1",
        "PCB0, PCB0"
      ],
      "answer": "PCB0, PCB1",
      "explanation": "Correct approach: each process’s state is saved/loaded in its own PCB."
    },
    {
      "id": "Q9-3",
      "question": "Which option matches the definition? \"Saves P0’s state in PCB1 and loads P1’s state from PCB1.\"",
      "options": [
        "PCB1, PCB0",
        "PCB0, PCB1",
        "PCB1, PCB1",
        "PCB0, PCB0"
      ],
      "answer": "PCB1, PCB1",
      "explanation": "Overwrites P1’s PCB with P0’s data, then tries to load from the same PCB. Incorrect."
    },
    {
      "id": "Q9-4",
      "question": "Which option matches the definition? \"Saves P0’s state in PCB0 but then reloads from PCB0 (never switching to P1).\"",
      "options": [
        "PCB1, PCB0",
        "PCB0, PCB1",
        "PCB1, PCB1",
        "PCB0, PCB0"
      ],
      "answer": "PCB0, PCB0",
      "explanation": "Would never actually switch to P1’s context."
    },
    {
      "id": "Q10-1",
      "question": "Which option matches the definition? \"Any of I/O requests, child creation, interrupts, or time-slice expiration can remove a process from CPU.\"",
      "options": [
        "all of the other answers",
        "I/O request",
        "fork a child",
        "interrupt or time slice expired"
      ],
      "answer": "all of the other answers",
      "explanation": "All listed events can cause a process to lose the CPU."
    },
    {
      "id": "Q10-2",
      "question": "Which option matches the definition? \"When a running process needs I/O, it must be removed from the CPU.\"",
      "options": [
        "all of the other answers",
        "I/O request",
        "fork a child",
        "interrupt or time slice expired"
      ],
      "answer": "I/O request",
      "explanation": "A running process that performs I/O is moved to the waiting (blocked) state."
    },
    {
      "id": "Q10-3",
      "question": "Which option matches the definition? \"Creating a new process can trigger the scheduler to preempt the current process.\"",
      "options": [
        "all of the other answers",
        "I/O request",
        "fork a child",
        "interrupt or time slice expired"
      ],
      "answer": "fork a child",
      "explanation": "fork() can cause a context switch if the OS decides to run the child or another process."
    },
    {
      "id": "Q10-4",
      "question": "Which option matches the definition? \"A hardware or software signal (or time limit) can stop the process, forcing a new process onto the CPU.\"",
      "options": [
        "all of the other answers",
        "I/O request",
        "fork a child",
        "interrupt or time slice expired"
      ],
      "answer": "interrupt or time slice expired",
      "explanation": "Preemptive OS scheduling can switch out a process on interrupt or time out."
    },
    {
      "id": "Q11-1",
      "question": "Which option matches the definition? \"Means background processes are visible to users.\"",
      "options": [
        "False",
        "True"
      ],
      "answer": "False",
      "explanation": "Choosing 'False' would claim background processes are apparent, which is incorrect."
    },
    {
      "id": "Q11-2",
      "question": "Which option matches the definition? \"Means background processes are not apparent to users.\"",
      "options": [
        "False",
        "True"
      ],
      "answer": "True",
      "explanation": "Background processes typically run without direct user interaction."
    },
    {
      "id": "Q12-1",
      "question": "Which option matches the definition? \"Would mean exec() spawns a totally new process with a new PID.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "But in reality, exec()  only replaces the current process image. exec() does not create a new process or change the PID."
    },
    {
      "id": "Q12-2",
      "question": "Which option matches the definition? \"Indicates exec() replaces the current process image, not creating a new process.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "False is correct because exec() does NOT create a new process (it overwrites the existing one)."
    },
    {
      "id": "Q13-1",
      "question": "Which option matches the definition? \"Indicates that upon termination, every process temporarily becomes a zombie until reaped.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "In most UNIX-like systems, the child remains a zombie until the parent calls wait()."
    },
    {
      "id": "Q13-2",
      "question": "Which option matches the definition? \"Means there's an exception to the zombie state for terminating processes.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "Standard approach is that every process becomes zombie briefly unless special reaping is used."
    },
    {
      "id": "Q14-1",
      "question": "Which option matches the definition? \"On a single-processor system, multiple processes can run simultaneously at exactly the same moment.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "Only one process can actually run at once on a single CPU."
    },
    {
      "id": "Q14-2",
      "question": "Which option matches the definition? \"On a single-processor system, only one process can be in the Running state at a time.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "You cannot literally run more than one process on one CPU core at the same moment."
    },
    {
      "id": "Q15-1",
      "question": "Which option matches the definition? \"Claims a program is the active entity, while a process is passive.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "A program is passive code; a process is actively executing."
    },
    {
      "id": "Q15-2",
      "question": "Which option matches the definition? \"Recognizes that a program is passive code, while a process is the active execution.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "Programs are passive on disk; processes run in memory."
    },
    {
      "id": "Q16-1",
      "question": "Which option matches the definition? \"A queue of hardware or software interrupts waiting to be handled.\"",
      "options": [
        "interrupt queue",
        "standby queue",
        "ready queue",
        "device queue"
      ],
      "answer": "interrupt queue",
      "explanation": "Interrupt queue is not for processes waiting on an I/O device or CPU time."
    },
    {
      "id": "Q16-2",
      "question": "Which option matches the definition? \"A queue that might be used for processes about to run, but not a common OS term.\"",
      "options": [
        "interrupt queue",
        "standby queue",
        "ready queue",
        "device queue"
      ],
      "answer": "standby queue",
      "explanation": "‘Standby queue’ is not standard terminology for device or CPU scheduling."
    },
    {
      "id": "Q16-3",
      "question": "Which option matches the definition? \"A queue of processes in memory, waiting for CPU time.\"",
      "options": [
        "interrupt queue",
        "standby queue",
        "ready queue",
        "device queue"
      ],
      "answer": "ready queue",
      "explanation": "The ready queue holds processes ready to execute on the CPU."
    },
    {
      "id": "Q16-4",
      "question": "Which option matches the definition? \"A queue of processes waiting for a specific I/O device to become available.\"",
      "options": [
        "interrupt queue",
        "standby queue",
        "ready queue",
        "device queue"
      ],
      "answer": "device queue",
      "explanation": "The device queue is for processes blocked, waiting on I/O for that device."
    },
    {
      "id": "Q17-1",
      "question": "Which option matches the definition? \"Message passing is usually faster than shared memory.\"",
      "options": [
        "Message passing is typically faster than shared memory.",
        "Message passing is most useful for exchanging large amounts of data.",
        "Shared memory is far more common in operating systems than message passing.",
        "Shared memory is typically faster than message passing."
      ],
      "answer": "Shared memory is typically faster than message passing.",
      "explanation": "Shared memory is usually faster once set up. Direct shared access avoids extra copies."
    },
    {
      "id": "Q17-2",
      "question": "Which option matches the definition? \"Message passing is most useful for very large data exchanges.\"",
      "options": [
        "Message passing is typically faster than shared memory.",
        "Message passing is most useful for exchanging large amounts of data.",
        "Shared memory is far more common in operating systems than message passing.",
        "Shared memory is typically faster than message passing."
      ],
      "answer": "Shared memory is usually better for large data.",
      "explanation": "Once mapped, processes can read/write large blocks directly. Large data transfers are generally more efficient via shared memory."
    },
    {
      "id": "Q17-3",
      "question": "Which option matches the definition? \"States that shared memory is used far more commonly than message passing in OSes.\"",
      "options": [
        "Message passing is typically faster than shared memory.",
        "Message passing is most useful for exchanging large amounts of data.",
        "Shared memory is far more common in operating systems than message passing.",
        "Shared memory is typically faster than message passing."
      ],
      "answer": "Shared memory is far more common in operating systems than message passing.",
      "explanation": "Both are common, though it’s not necessarily absolute. It was one of the statements."
    },
    {
      "id": "Q17-4",
      "question": "Which option matches the definition? \"Once set up, processes can exchange large data faster by direct memory access rather than repeated message copying.\"",
      "options": [
        "Message passing is typically faster than shared memory.",
        "Message passing is most useful for exchanging large amounts of data.",
        "Shared memory is far more common in operating systems than message passing.",
        "Shared memory is typically faster than message passing."
      ],
      "answer": "Shared memory is typically faster than message passing.",
      "explanation": "Because shared memory avoids repeated system calls for large data transfers."
    },
    {
      "id": "Q18-1",
      "question": "Which option matches the definition? \"Not a recognized OS term for the action of switching processes.\"",
      "options": [
        "None of the other answers",
        "state switch",
        "save-and-restore",
        "context switch"
      ],
      "answer": "None of the other answers",
      "explanation": "Used if none of the others matched. Usually 'context switch' is the correct term."
    },
    {
      "id": "Q18-2",
      "question": "Which option matches the definition? \"A non-standard phrase describing process switching, but not the typical name.\"",
      "options": [
        "None of the other answers",
        "state switch",
        "save-and-restore",
        "context switch"
      ],
      "answer": "state switch",
      "explanation": "'State switch' is not the common OS terminology. 'Context switch' is standard."
    },
    {
      "id": "Q18-3",
      "question": "Which option matches the definition? \"Descriptive of saving one process state and loading another, though not the formal OS term.\"",
      "options": [
        "None of the other answers",
        "state switch",
        "save-and-restore",
        "context switch"
      ],
      "answer": "save-and-restore",
      "explanation": "It’s a plain description, but the official name is context switch."
    },
    {
      "id": "Q18-4",
      "question": "Which option matches the definition? \"The official OS operation saving a process’s CPU state and restoring another’s.\"",
      "options": [
        "None of the other answers",
        "state switch",
        "save-and-restore",
        "context switch"
      ],
      "answer": "context switch",
      "explanation": "Context switch is the standard term in operating systems."
    },
    {
      "id": "Q19-1",
      "question": "Which option describes the degree of multiprogramming for a single-processor system: 1, 0, 2, 3?",
      "options": [
        "1",
        "0",
        "2",
        "3"
      ],
      "answer": "1",
      "explanation": "A single CPU can run only one process at a time, so its degree of multiprogramming is 1."
    },
    {
      "id": "Q20-1",
      "question": "Which option matches the definition? \"When a ready process is selected by the CPU scheduler, it transitions to this.\"",
      "options": [
        "ready",
        "waiting",
        "running",
        "terminated"
      ],
      "answer": "running",
      "explanation": "A ready process moves to running once it’s given CPU time."
    },
    {
      "id": "Q21-1",
      "question": "Which option matches the definition? \"All IPC facilities are automatically shared between parent and child processes.\"",
      "options": [
        "All IPC facilities are shared between the parent and child processes.",
        "A pipe is treated as a file descriptor, inherited by the child via fork().",
        "The STARTUPINFO structure establishes pipe sharing.",
        "Pipes are part of the code inherited from the parent."
      ],
      "answer": "Only certain facilities are inherited",
      "explanation": "For example, open file descriptors/handles may be, but not all IPC is guaranteed. All IPC facilities are shared between the parent and child processes."
    },
    {
      "id": "Q21-2",
      "question": "Which option matches the definition? \"Because pipes are file descriptors, the child process gets them upon fork.\"",
      "options": [
        "All IPC facilities are shared between the parent and child processes.",
        "A pipe is treated as a file descriptor, inherited by the child via fork().",
        "The STARTUPINFO structure establishes pipe sharing.",
        "Pipes are part of the code inherited from the parent."
      ],
      "answer": "A pipe is treated as a file descriptor, inherited by the child via fork().",
      "explanation": "In UNIX, open file descriptors are duplicated into the child."
    },
    {
      "id": "Q21-3",
      "question": "Which option matches the definition? \"A Windows-specific structure controlling which handles are inherited; not standard UNIX.\"",
      "options": [
        "All IPC facilities are shared between the parent and child processes.",
        "A pipe is treated as a file descriptor, inherited by the child via fork().",
        "The STARTUPINFO structure establishes pipe sharing.",
        "Pipes are part of the code inherited from the parent."
      ],
      "answer": "The STARTUPINFO structure establishes pipe sharing.",
      "explanation": "STARTUPINFO is a Windows structure, not how UNIX does pipe inheritance."
    },
    {
      "id": "Q21-4",
      "question": "Which option matches the definition? \"Claims that pipes are part of the program code, so children inherit them with code.\"",
      "options": [
        "All IPC facilities are shared between the parent and child processes.",
        "A pipe is treated as a file descriptor, inherited by the child via fork().",
        "The STARTUPINFO structure establishes pipe sharing.",
        "Pipes are part of the code inherited from the parent."
      ],
      "answer": "Pipes are part of the code inherited from the parent.",
      "explanation": "Incorrect, as pipes are special file descriptors, not code segments."
    },
    {
      "id": "Q22-1",
      "question": "Which option matches the definition? \"Historically, the very first user-space process (PID 1) in Linux.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "init is typically PID 1 and spawns or manages other processes."
    },
    {
      "id": "Q22-2",
      "question": "Which option matches the definition? \"Means init is not the first process started on a Linux system.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "That’s incorrect; init (or systemd) is indeed the first user-mode process."
    },
    {
      "id": "Q23-1",
      "question": "Which option matches the definition? \"Named pipes (FIFOs) can only be used by a parent and its child.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "This is actually correct for FIFOs. Named pipes allow unrelated processes to exchange data."
    },
    {
      "id": "Q23-2",
      "question": "Which option matches the definition? \"Named pipes do not require related processes; any process with the name/path can communicate.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "FIFOs just require the path, not parent-child relationship. "
    },
    {
      "id": "Q24-1",
      "question": "Which option matches the definition? \"A program is active, while a process is passive.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "Programs are passive code, processes are active entities. It’s the opposite in OS terms."
    },
    {
      "id": "Q24-2",
      "question": "Which option matches the definition? \"A program is passive code on disk, while a process is an active entity in memory.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "Program = passive; Process = active."
    },
    {
      "id": "Q25-1",
      "question": "Which option matches the definition? \"When a process’s time slice ends or it’s preempted, it returns to ready.\"",
      "options": [
        "Awaiting its turn on the CPU",
        "Completion of an I/O event",
        "All the other answers",
        "Newly-admitted process"
      ],
      "answer": "Awaiting its turn on the CPU",
      "explanation": "A running process can go back to ready if interrupted or time-slice is up."
    },
    {
      "id": "Q25-2",
      "question": "Which option matches the definition? \"A process was waiting for I/O and, when done, it goes back to ready.\"",
      "options": [
        "Awaiting its turn on the CPU",
        "Completion of an I/O event",
        "All the other answers",
        "Newly-admitted process"
      ],
      "answer": "Completion of an I/O event",
      "explanation": "Processes in waiting state for I/O will move to ready once I/O completes."
    },
    {
      "id": "Q25-3",
      "question": "Which option matches the definition? \"Indicates that any of the listed cases will transition a process into ready state.\"",
      "options": [
        "Awaiting its turn on the CPU",
        "Completion of an I/O event",
        "All the other answers",
        "Newly-admitted process"
      ],
      "answer": "All the other answers",
      "explanation": "All those actions can cause a process to move to ready."
    },
    {
      "id": "Q25-4",
      "question": "Which option matches the definition? \"A fresh process enters the system and is placed in ready state.\"",
      "options": [
        "Awaiting its turn on the CPU",
        "Completion of an I/O event",
        "All the other answers",
        "Newly-admitted process"
      ],
      "answer": "Newly-admitted process",
      "explanation": "A new process typically goes to ready when it’s initialized."
    },
    {
      "id": "Q26-1",
      "question": "Which option matches the definition? \"An example of a process queue (holding multiple processes).\"",
      "options": [
        "is an example of a process queue",
        "determines which process is to be executed next",
        "stores address of the next instruction for a different process",
        "includes info on the process's state"
      ],
      "answer": "Stores a single process’s data",
      "explanation": "A PCB is for a single process, not a queue of many. Each PCB holds info about one process."
    },
    {
      "id": "Q26-2",
      "question": "Which option matches the definition? \"A scheduling function that selects which process runs next.\"",
      "options": [
        "is an example of a process queue",
        "determines which process is to be executed next",
        "stores address of the next instruction for a different process",
        "includes info on the process's state"
      ],
      "answer": "Describes a PCB’s role storing process state",
      "explanation": "That’s the scheduler’s job, The PCB doesn’t pick who runs next; the scheduler does.."
    },
    {
      "id": "Q26-3",
      "question": "Which option matches the definition? \"Keeps the next instruction pointer for a different process than the one whose PCB this is.\"",
      "options": [
        "is an example of a process queue",
        "determines which process is to be executed next",
        "stores address of the next instruction for a different process",
        "includes info on the process's state"
      ],
      "answer": "Stores the program counter for its own process",
      "explanation": "Each PCB is unique to the process it describes. A PCB stores data for its own process, not some other one."
    },
    {
      "id": "Q26-4",
      "question": "Which option matches the definition? \"Holds data like the process state, program counter, registers, memory limits, etc.\"",
      "options": [
        "is an example of a process queue",
        "determines which process is to be executed next",
        "stores address of the next instruction for a different process",
        "includes info on the process's state"
      ],
      "answer": "includes info on the process's state",
      "explanation": "A PCB is the repository of essential process info."
    },
    {
      "id": "Q27-1",
      "question": "Which option matches the definition? \"The long-term scheduler that decides which jobs to bring into the system.\"",
      "options": [
        "long-term scheduler",
        "degree of multiprogramming",
        "process count",
        "CPU Scheduler"
      ],
      "answer": "long-term scheduler",
      "explanation": "Also called job scheduler, controlling job admission."
    },
    {
      "id": "Q27-2",
      "question": "Which option matches the definition? \"The number of processes in main memory at one time.\"",
      "options": [
        "long-term scheduler",
        "degree of multiprogramming",
        "process count",
        "CPU Scheduler"
      ],
      "answer": "degree of multiprogramming",
      "explanation": "‘Degree of multiprogramming’ measures how many processes are loaded."
    },
    {
      "id": "Q27-3",
      "question": "Which option matches the definition? \"A generic label that might just count processes without specifying if they’re all in memory.\"",
      "options": [
        "long-term scheduler",
        "degree of multiprogramming",
        "process count",
        "CPU Scheduler"
      ],
      "answer": "process count",
      "explanation": "This is a more general term, not specifically an OS scheduling concept."
    },
    {
      "id": "Q27-4",
      "question": "Which option matches the definition? \"Short-term scheduler that decides from the ready queue who gets the CPU next.\"",
      "options": [
        "long-term scheduler",
        "degree of multiprogramming",
        "process count",
        "CPU Scheduler"
      ],
      "answer": "CPU Scheduler",
      "explanation": "CPU Scheduler is separate from the measure of how many processes are in memory."
    },
    {
      "id": "Q28-1",
      "question": "Which option matches the definition? \"Holds compiled instructions for the program; not for dynamic data.\"",
      "options": [
        "text section",
        "stack section",
        "heap section",
        "data section"
      ],
      "answer": "text section",
      "explanation": "Text section is the code of the program."
    },
    {
      "id": "Q28-2",
      "question": "Which option matches the definition? \"Stores local variables, function calls, and return addresses, typically grows downward.\"",
      "options": [
        "text section",
        "stack section",
        "heap section",
        "data section"
      ],
      "answer": "stack section",
      "explanation": "The stack is used for function frames and local variables."
    },
    {
      "id": "Q28-3",
      "question": "Which option matches the definition? \"Used for dynamic allocations at runtime (malloc/new).\"",
      "options": [
        "text section",
        "stack section",
        "heap section",
        "data section"
      ],
      "answer": "heap section",
      "explanation": "The heap grows/shrinks as memory is allocated or freed dynamically."
    },
    {
      "id": "Q28-4",
      "question": "Which option matches the definition? \"Holds global or static variables, allocated once when the program starts.\"",
      "options": [
        "text section",
        "stack section",
        "heap section",
        "data section"
      ],
      "answer": "data section",
      "explanation": "Data section is for global/static data."
    },
    {
      "id": "Q29-1",
      "question": "Which option matches the definition? \"Queue of processes waiting for a specific I/O device.\"",
      "options": [
        "device queue",
        "ready queue",
        "interrupt queue",
        "standby queue"
      ],
      "answer": "device queue",
      "explanation": "A device queue holds processes blocked on I/O for that device."
    },
    {
      "id": "Q29-2",
      "question": "Which option matches the definition? \"Processes in memory, ready to run on the CPU but not running.\"",
      "options": [
        "device queue",
        "ready queue",
        "interrupt queue",
        "standby queue"
      ],
      "answer": "ready queue",
      "explanation": "The ready queue is for processes that can run but don’t have the CPU yet."
    },
    {
      "id": "Q29-3",
      "question": "Which option matches the definition? \"A list of pending hardware or software interrupts.\"",
      "options": [
        "device queue",
        "ready queue",
        "interrupt queue",
        "standby queue"
      ],
      "answer": "interrupt queue",
      "explanation": "Interrupt queue is separate from processes waiting to run or for I/O."
    },
    {
      "id": "Q29-4",
      "question": "Which option matches the definition? \"A less common term, not standard for CPU or I/O scheduling.\"",
      "options": [
        "device queue",
        "ready queue",
        "interrupt queue",
        "standby queue"
      ],
      "answer": "standby queue",
      "explanation": "‘Standby queue’ is not a typical OS scheduling term."
    },
    {
      "id": "Q30-1",
      "question": "Which option matches the definition? \"Ordinary pipes only allow one-way communication.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "Unix pipes are unidirectional: one end writes, the other reads."
    },
    {
      "id": "Q30-2",
      "question": "Which option matches the definition? \"Ordinary pipes can be used for two-way communication with only one pipe.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "False indicates that a single ordinary pipe does NOT support bidirectional exchange."
    },
    {
      "id": "Q31-1",
      "question": "Which option matches the definition? \"Every read/write to POSIX shared memory must involve a system call.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "After mapping, you can access shared memory directly in user space. System calls are only needed to set up/tear down, not for each access."
    },
    {
      "id": "Q31-2",
      "question": "Which option matches the definition? \"Once memory is mapped, processes can read/write it directly without extra syscalls.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "This is actually correct for shared memory usage. Direct access to the mapped region doesn’t require additional calls."
    },
    {
      "id": "Q32-1",
      "question": "Which option matches the definition? \"Shared memory is more appropriate than message passing for distributed systems.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "False",
      "explanation": "Distributed systems typically do not share physical memory across nodes. They generally favor message passing over a network. "
    },
    {
      "id": "Q32-2",
      "question": "Which option matches the definition? \"Distributed systems usually favor message passing since they do not share the same memory.\"",
      "options": [
        "True",
        "False"
      ],
      "answer": "True",
      "explanation": "It’s actually true that distributed processes can’t share the same physical address space. Message passing is the standard approach for separate machines."
    },
    {
      "id": "Q33-1",
      "question": "Which option matches the definition? \"Terminates the current process and returns an exit status.\"",
      "options": [
        "exit()",
        "exec()",
        "fork()",
        "wait()"
      ],
      "answer": "exit()",
      "explanation": "exit() ends a process; not for loading a new program."
    },
    {
      "id": "Q33-2",
      "question": "Which option matches the definition? \"Overwrites the existing process image with a new program in the same PID.\"",
      "options": [
        "exit()",
        "exec()",
        "fork()",
        "wait()"
      ],
      "answer": "exec()",
      "explanation": "exec() replaces the current code and data of the process."
    },
    {
      "id": "Q33-3",
      "question": "Which option matches the definition? \"Creates a new child process as a clone of the current one.\"",
      "options": [
        "exit()",
        "exec()",
        "fork()",
        "wait()"
      ],
      "answer": "fork()",
      "explanation": "fork() duplicates the calling process (parent)."
    },
    {
      "id": "Q33-4",
      "question": "Which option matches the definition? \"Blocks the calling process until one of its child processes exits.\"",
      "options": [
        "exit()",
        "exec()",
        "fork()",
        "wait()"
      ],
      "answer": "wait()",
      "explanation": "wait() suspends the parent until a child terminates."
    },
    {
      "id": "Q34-1",
      "question": "Which concept is described by: \"A region of a process’s memory used for dynamic allocations at runtime.\"",
      "options": [
        "heap",
        "stack",
        "data section",
        "text section"
      ],
      "answer": "heap",
      "explanation": "The heap grows as you allocate with malloc/new and is distinct from stack/data/text."
    }
  ]
}
